<script context="module" lang="ts">
import type { ComponentType } from 'svelte';

export interface Instructs {
    key: string,
    title?: string,
    sortable?: boolean,
    sortCaseSensitive?: boolean,
    filterable?: boolean,
    filterPhrase?: string,
    filterIsRegex?: boolean,
    parseAs?: 'text' | 'html' | 'unsafe-html' | 'component',
    edit?: {
        component: ComponentType<SvelteComponent>,
        props: object,
    }
    userFunctions?: {
        customSort?(v1: string, v2: string): number,
        customFilter?(data: Data[], searchPhrase: string): {data: Data[], continue: boolean},
    },
    dataComponent?: ComponentType<SvelteComponent>,
}

export interface Data {
    [_: string]: any,
}


type SortString = ''|'asc'|'desc';
export type Sorting = Record<string, SortString>;

export interface Options {
    uniquePrefix?: string,
    rowsPerPageOptions?: number[],
    rowsPerPage?: number,
    paginationBlock?: 3|5|7|9|11|13|15|17|19,
    headerText?: boolean,
    footerText?: boolean,
    headerFilters?: boolean,
    footerFilters?: boolean,
    headerLoadingBar?: boolean,
    footerLoadingBar?: boolean,
    defaultRegexFlags?: string,
    nestedSorting?: boolean,
    isDataRemote?: boolean,
    totalRows?: number|null,
    filteredRows?: number|null,
    currentPage?: number,
    searchPhrase?: string,
    searchIsRegex?: boolean,
    checkboxColumn?: boolean,
    translations?: {
        numberFormat?: string,
        search?: string,
        previous?: string,
        next?: string,
        rows?: string,
        filterBy?: string,
        of?: string,
        from?: string
        selectAll?: string, 
        selectNone?: string, 
        invertSelection?: string, 
        add?: string, 
        delete?: string, 
        checkboxHide?: string
        checkboxShow?: string
    },
    userFunctions?: {
        dataFeed?(data: Record<string,any>): Promise<DataFeed>,
        customParse?(data: Data[]): Data[],
        customSearch?(data: Data[], searchPhrase: string): {data: Data[], continue: boolean},
        deleteActionCallback?(rows: Data[]): void,
        editSubmissionCallback?(row: Data): void,
    },
    segments?: Record<string,Array<'settings'|'search'|'pagination'|'table'|'dropdown'|'stats'>>,
    sortOrder?: {[k in SortString]?: SortString},
}

interface Pagination {
    totalRows?: number,
    firstShownRow?: number,
    lastShownRow?: number,
    totalPages?: number,
    pages?: number[],
}

export interface DataFeed {
    instructs?: Instructs[],
    options?: Options,
    data?: Data[],
    sorting?: Sorting,
}

export type RegexParts = {
    delimiter: string,
    pattern: string,
    flags: string
}

type Lookup = {
    value?: string,
    isRegex?: boolean,
    isCustom?: boolean
}

// PowerTable internal id key name
export let dataIdKey = '__PT_ID__';
// PowerTable check box key name
export let checkboxKey = '__PT_CB__';

// If phrase is a valid regex, return the regex parts
export function getRegexParts(phrase: string) {
    if (phrase.length > 1){
        try {
            const groups = phrase.match(/^([/~#;%@'])(.+)\1([gimsuy]*)$/);
            if(groups && !!new RegExp(groups[2],groups[3])) {
                return <RegexParts>{
                    delimiter: groups[1],
                    pattern: groups[2],
                    flags: groups[3]
                }
            }
        } catch (e) {}
    }
    return false;
}
</script>

<script lang="ts">
import { onMount, createEventDispatcher } from 'svelte';
import type { SvelteComponent } from "svelte"
import DefaultEditComponent from './DefaultEditComponent.svelte';

// Props
export let ptInstructs: Instructs[] = [];
export let ptOptions: Options = {};
export let ptData: Data[] = [];

let specialInstructs = {
    [dataIdKey]: {
        key: dataIdKey,
        title: '',
        sortable: false,
        filterable: false,
    },
    [checkboxKey]: {
        key: checkboxKey,
        title: '',
        sortable: false,
        filterable: false,
    }
}

const dispatch = createEventDispatcher();

// Associated with options prop (ptOptions) for internal use
let options: Options = {
    uniquePrefix: 'pt',
    rowsPerPageOptions: [5, 10, 20, 50, 100],
    rowsPerPage: 10,
    paginationBlock: 3,
    headerText: true,
    footerText: true,
    headerFilters: true,
    footerFilters: true,
    headerLoadingBar: true,
    footerLoadingBar: true,
    defaultRegexFlags: 'gimsu',
    nestedSorting: false,
    isDataRemote: false,
    totalRows: null,
    filteredRows: null,
    currentPage: 1,
    searchPhrase: '',
    searchIsRegex: false,
    checkboxColumn: false,
    translations: {
        numberFormat: 'en-US',
        search: 'Search',
        previous: 'Previous',
        next: 'Next',
        rows: 'Rows',
        filterBy: 'Filter by',
        of: 'of',
        from: 'from',
        selectAll: 'Select All',
        selectNone: 'Select None',
        invertSelection: 'Invert Selection',
        add: 'Add',
        delete: 'Delete',
        checkboxHide: 'Hide Checkboxes',
        checkboxShow: 'Show Checkboxes'
    },
    userFunctions: {
        dataFeed: async () => ({}),
    },
    segments: {
        'topBar': ['search', 'pagination'],
        'pTable': ['table'],
        'bottomBar': ['dropdown', 'stats', 'pagination'],
    },
    sortOrder: {
        '': 'asc',
        'asc': 'desc',
        'desc': '',
    },
}

// Associated with instructs prop (ptInstructs) for internal use
let instructs: Instructs[];

// Associated with data prop (ptData) for internal use
let data: Data[];

// Changes in props triggers the initialize function
$: initialize(ptInstructs, ptOptions, ptData);

// Filtered and searched data
let matchedData: Data[];
// Sorted data
let sortedData: Data[] = [];
// Data of the current page 
let pageData: Data[] = [];
// pageData after applying a user defined format function
let formattedPageData: Data[] = [];

let pagination: Pagination = {
    totalRows: 0,
    firstShownRow: 0,
    lastShownRow: 0,
    totalPages: 1,
    pages: [1],
};

let sorting: Record<string,SortString> = {};
let renderStatus: string|null = null;
let searchObj: Lookup = {};
let filterObj: Record<string,Lookup> = {};


function initialize(ptInstructs: Instructs[], ptOptions: Options, ptData: Record<string,any>[], action: {render?:boolean, preserveFilters?: boolean} = {render: true, preserveFilters: true}) {
    if (ptOptions) {
        Object.assign(options, ptOptions);
    }
    options = options;

    // If search object is not set or should not be preserved, reset it
    // The `preserveFilters` action is intended to affect both "filters" and "search"
    if (!searchObj?.value || !action?.preserveFilters){
        searchObj = {
            value: options.searchPhrase,
            isRegex: options.searchIsRegex,
            isCustom: false
        }
    }

    data = JSON.parse(JSON.stringify(ptData));

    // Make data type conformable to Record<string,string>
    data = data.map(row => {
        Object.keys(row).forEach(key => {
            // If not a special instruct
            if (!specialInstructs.hasOwnProperty(key)) {
                if (row[key] === null) {
                    row[key] = '';
                } else if (typeof row[key] === 'object') {
                    row[key] = JSON.stringify(row[key]);   
                } else {
                    row[key] = row[key].toString();
                }
            }
        });
        return row;
    });

    let tempInstructs: Instructs[] = [];

    // If ptInstructs prop is empty
    if (!ptInstructs?.length) {
        let firstRecordKeys = Object.keys(data?.[0] ?? []);
        firstRecordKeys.forEach(key => {
            // If not a special instruct (they will be added later)
            if (!specialInstructs.hasOwnProperty(key)) {
                tempInstructs.push({
                    key: key,
                    title: key,
                    parseAs: 'text',
                    edit: {component: <ComponentType<SvelteComponent>>DefaultEditComponent, props: {}}
                });

                filterObj[key] = {
                    value: '',
                    isRegex: false,
                    isCustom: false
                }
            }
        });
        instructs = tempInstructs;
    } else {
        ptInstructs?.forEach(instruct => {
            // If not a special instruct (they will be added later)
            if (!specialInstructs.hasOwnProperty(instruct.key)) {
                // add default values for an instruct
                if (!instruct.hasOwnProperty('title')) {
                    instruct['title'] = instruct['key'];
                }
                if (!instruct.hasOwnProperty('edit')) {
                    instruct['edit'] = {component: <ComponentType<SvelteComponent>>DefaultEditComponent, props: {}}
                }

                tempInstructs.push(instruct);

                // If filters aren't set or should not be preserved, reset them
                if (!filterObj[instruct.key] || !action?.preserveFilters){
                    filterObj[instruct.key] = {
                        value: instruct?.filterPhrase ?? '',
                        isRegex: instruct?.filterIsRegex ?? false,
                        isCustom: false
                    }
                }
            }
        });
        instructs = tempInstructs;
    }

    // Handling spacial instructs
    // Add checkboxes
    if (!instructs?.[0]?.hasOwnProperty(checkboxKey)) {
        instructs = [specialInstructs[checkboxKey], ...instructs];

        filterObj[checkboxKey] = {
            value: '',
            isRegex: false,
            isCustom: false
        }
    }

    let checkboxExists = data?.[0]?.hasOwnProperty(checkboxKey);

    // Add data associated with spacial instructs
    data = data.map((row, index) => {
        // Re-index
        Object.keys(row).forEach(() => delete row[dataIdKey]);
        row = Object.assign({[dataIdKey]: index}, row);

        if (!checkboxExists) {
            row = Object.assign({[checkboxKey]: false}, row);
        }

        return row
    });

    if (action?.render) {
        renderTable();
    }
}

async function renderTable() {
    renderStatus = 'rendering';

    if (options.isDataRemote) {
        let remoteParams: {
            options?: object,
            search?: object,
            filters?: object,
            sorting?: object,
        } = {};

        remoteParams['options'] = options;
        remoteParams['search'] = searchObj;
        remoteParams['filters'] = filterObj;
        remoteParams['sorting'] = sorting;

        let newData = await options.userFunctions?.dataFeed!(remoteParams);
        if (newData?.data) {
            initialize(newData.instructs ?? [], newData.options ?? {}, newData.data, {render: false, preserveFilters: true});
            // Already filtered on the server
            matchedData = data;
            // Already sorted on the server
            sortedData = matchedData;
        }
    } else {
        applyFilters();
        applySort();
    }

    applyPagination();

    renderStatus = 'completed';
}

function trackSorting(key: string) {
    let newSortingState = <SortString>options.sortOrder![sorting?.[key] ?? ''];
    if (!options.nestedSorting) { sorting = {}; }
    sorting[key] = newSortingState;
    if (sorting[key] === '') { delete sorting[key]; }
    renderTable();
}

// Applies sorting when data is not remote
function applySort() {
    //*****************************************//
    /* https://github.com/Teun/thenBy.js/blob/master/thenBy.js
        Copyright 2013 Teun Duynstee
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    const firstBy = (function() {
        const preserveCase = (v: string) => v;
        const removeCase = (v: string) => typeof(v) === "string" ? v.toLowerCase() : v;
        const makeCompareFunction = (f:any, opt:any) => {
            opt = typeof(opt) === "object" ? opt : {direction: opt};
            if(typeof(f)!="function"){var prop = f; f = function(v1:any){return !!v1[prop] ? v1[prop] : "";}}
            if(f.length === 1) {
                var uf = f;
                var preProcess = opt.caseSensitive ? preserveCase : removeCase;
                var cmp = opt.cmp || function(v1: string, v2: string) { return v1 < v2 ? -1 : v1 > v2 ? 1 : 0;};
                f = (v1: string, v2: string) => cmp(preProcess(uf(v1)), preProcess(uf(v2)));
            }
            const descTokens = {"-1":'', desc:''};
            if(opt.direction in descTokens) return function(v1: string, v2: string){return -f(v1,v2)};
            return f;
        }

        function tb(func:any, opt:any): Function {
            // @ts-ignore
            var x = (typeof(this) === "function" && !this.firstBy) ? this : false;
            var y = makeCompareFunction(func, opt);
            var f = x ? function(a:any, b:any) { return x(a,b) || y(a,b); } : y;
            f.thenBy = tb;
            return f;
        }

        tb.firstBy = tb;
        return tb;
    })();
    //*****************************************//

    sortedData = matchedData;

    let compFunc: any;

    if (Object.keys(sorting).length){
        Object.entries(sorting).forEach(([key, dir], index) => {
            let opt: {
                caseSensitive: boolean,
                direction: SortString,
                cmp?: Function
            } = {
                caseSensitive: false,
                direction: dir
            }

            let instruct = instructs.find(instruct => instruct.key === key);
            if (instruct?.sortCaseSensitive) {
                opt.caseSensitive = true;
            }
            if (instruct?.userFunctions?.customSort) {
                opt.cmp = instruct.userFunctions.customSort;
            }

            if (index === 0) {
                compFunc = firstBy(key, opt);
            } else {
                compFunc = compFunc.thenBy(key, opt);
            }
        });

        sortedData = sortedData.sort(compFunc);
    }
}

// Applies filters and search, when data is not remote
function applyFilters() {
    // Make a copy of original data
    matchedData = JSON.parse(JSON.stringify(data));
    let previousSearchObj: Lookup = JSON.parse(JSON.stringify(searchObj));
    searchObj.isRegex = false;
    searchObj.isCustom = false;

    if (searchObj.value) {
        // By default search continues after a custom search
        let customSearchContinue: boolean = true;

        if (typeof (options.userFunctions?.customSearch ?? null) === 'function' && options.userFunctions?.customSearch !== undefined) {
            let customSearchResult = options.userFunctions.customSearch(matchedData, searchObj.value);
            matchedData = customSearchResult.data;
            customSearchContinue = customSearchResult.continue;
            searchObj.isCustom = !customSearchContinue;
        }

        // Filter out any row that doesn't match the searched phrase
        if (customSearchContinue !== false) {
            let regexParts: RegexParts | boolean = getRegexParts(searchObj.value);
            let regexp: RegExp;

            if (regexParts) {
                try {
                    let flags: string | undefined = regexParts.flags;
                    searchObj.isRegex = true;

                    // Unless all flags are just being deleted from a regex, add the default flags
                    if ( ! regexParts?.flags && ! previousSearchObj.isRegex) {
                        flags = options.defaultRegexFlags;
                        searchObj.value += flags;
                    }

                    regexp = new RegExp(regexParts.pattern, flags);
                } catch(e) {}
            }

            if (searchObj.isRegex) {
                matchedData = matchedData.filter(d => {
                    return Object.keys(d).some(key => {
                        if (!specialInstructs.hasOwnProperty(key)) {
                            return regexp.test(d?.[key]);
                        } else {
                            return false;
                        }
                    });
                });
            } else {
                let words = searchObj.value.trim().toLowerCase().match(/\S+/g);

                // Iterate over the rows
                matchedData = matchedData.filter(d => {
                    let unmatchedWords = Object.assign([], words);
                    // Iterate over the fields and remove the matching words from unmatchedWords
                    for (let key of Object.keys(d)) {
                        // If not a special column (e.g. checkboxes)
                        if (!specialInstructs.hasOwnProperty(key)) {
                            let searchableString: string = d?.[key]?.toString()?.toLowerCase();
                            unmatchedWords = <never[] & RegExpMatchArray>unmatchedWords.filter((word: string) => {
                                if (searchableString?.indexOf(word) > -1) {
                                    return false;
                                }
                                return true;
                            });
                        }
                    }

                    return !unmatchedWords.length;
                });
            } 
        }
    }

    // Filter out any row that doesn't match the filter phrases
    Object.entries(filterObj).forEach(([key, filter]) => {
        let previousFilter: Lookup = JSON.parse(JSON.stringify(filter));
        filterObj[key].isRegex = false;
        filterObj[key].isCustom = false;

        if (filter.value?.length) {
            // By default filter continues after a custom filter
            let customFilterContinue: boolean = true;

            let correspondingInstruct = instructs.find(d => d.key === key);

            if (typeof (correspondingInstruct?.userFunctions?.customFilter ?? null) === 'function' && correspondingInstruct?.userFunctions?.customFilter !== undefined) {
                let customFilterResult = correspondingInstruct.userFunctions.customFilter(matchedData, filter.value);
                matchedData = customFilterResult.data;
                customFilterContinue = customFilterResult.continue;
                filterObj[key].isCustom = !customFilterContinue;
            }

            if (customFilterContinue !== false) {
                let regexParts: RegexParts | boolean = getRegexParts(filter.value);

                if (regexParts) {
                    // If the regex format is invalid (e.g. wrong flags), revert to literal search
                    try {
                        let flags: string | undefined = regexParts.flags;
                        filterObj[key].isRegex= true;

                        // Unless all flags are just being deleted from a regex, add the default flags
                        if ( ! regexParts?.flags && ! previousFilter.isRegex && filterObj[key]?.value) {
                            flags = options.defaultRegexFlags;
                            filterObj[key].value! += flags;
                        }

                        // @ts-ignore Shhhh!
                        matchedData = matchedData.filter(d => new RegExp(regexParts.pattern, flags).test(d[key]));
                    } catch(e) {}
                }

                if ( ! filter.isRegex) {
                    let words = filter.value.trim().toLowerCase().match(/\S+/g);

                    // Iterate over the rows and remove the matching words from unmatchedWords
                    matchedData = matchedData.filter(d => {
                        let unmatchedWords = Object.assign([], words);
                        let searchableString = d?.[key]?.toString()?.toLowerCase();
                        unmatchedWords = <never[] & RegExpMatchArray>unmatchedWords.filter((word: string) => {
                            if (searchableString?.indexOf(word) > -1) {
                                return false;
                            }
                            return true;
                        });                

                        return !unmatchedWords.length;
                    });
                } 
            }
        }
    });

    if (matchedData.length !== data?.length) {
        options.currentPage = 1;
    }
}

function applyPagination() {
    let p: Pagination & Options = {};
    p.totalRows = options?.totalRows ?? data?.length;
    p.filteredRows = options?.filteredRows ?? sortedData?.length;

    // When deleting a large number of rows, the currentPage might remain higher than the last page
    if (options?.currentPage! > p.totalRows / options?.rowsPerPage!) {
        options.currentPage = Math.ceil(p.totalRows / options?.rowsPerPage!);
        // The lowest currentPage (e.g. when there is no rows) at this point should be 1. Otherwise, firstShownRow will become negative
        if (options.currentPage < 1) {
            options.currentPage = 1;
        }
    }
    p.firstShownRow = Math.min(p.filteredRows, ((options?.currentPage! - 1) * options?.rowsPerPage!) + 1);
    p.lastShownRow = Math.min(p.filteredRows, options.currentPage! * options.rowsPerPage!);
    if (options.rowsPerPage) {
        p.totalPages = Math.ceil(p.filteredRows / options.rowsPerPage);
    }

    p.pages = [1];

    // Page #2 or '...' if too many pages (more than sum of first two pages + block + last two pages)
    if (options.currentPage! <= options.paginationBlock! + 1 || p.totalPages! <= options.paginationBlock! + 4) {
        if (p.totalPages! > 1) {
            p.pages.push(2);
        }
    } else if (p.totalPages! > options.paginationBlock! + 4) {
        p.pages.push(0);
    }

    // Construct the middle block when the currentPage is close enough to page #1 or there aren't too many pages
    if (options.currentPage! <= options.paginationBlock! + 1 || p.totalPages! <= options.paginationBlock! + 4) {
        [...Array(options.paginationBlock)].forEach((_, index) => {
            // Exclude the last page if falls within this block
            if ((index + 3) < p.totalPages!) {
                p.pages!.push(index + 3);
            }
        });
    }
    // Construct the middle block when the currentPage far from the last page (and the first page)
    else if (p.totalPages! - options.currentPage! > options.paginationBlock!) {
        [...Array((options.paginationBlock! - 1)/2)].forEach((_, index) => {
            p.pages!.push(options.currentPage! - (index + 1));
        });

        p.pages.push(options.currentPage!);

        [...Array((options.paginationBlock! - 1)/2)].forEach((_, index) => {
            p.pages!.push(options.currentPage! + (index + 1));
        });
    }
    // Construct the middle block when the currentPage is far from the first and last page
    else {
        [...Array(options.paginationBlock)].forEach((_,index) => {
            p.pages!.push(p.totalPages! - (4 - index));
        });
    }

    // Next to last page
    if (p.totalPages! > options.paginationBlock! + 3) {
        if (options.currentPage! >= p.totalPages! - options.paginationBlock!) {
            p.pages.push(p.totalPages! - 1);
        } else {
            p.pages.push(0);
        }
    }

    // The last page
    if (p.totalPages! >= 3) {
        p.pages.push(p.totalPages!);
    }

    if (!options.isDataRemote) {
        // Slice the rows of the current page
        pageData = sortedData.slice(p.firstShownRow! - 1, p.lastShownRow!);
    } else {
        pageData = sortedData;
    }

    if (typeof (options.userFunctions?.customParse ?? null) === 'function' && options.userFunctions?.customParse !== undefined) {
        formattedPageData = options.userFunctions.customParse(JSON.parse(JSON.stringify(pageData)));
    } else {
        formattedPageData = JSON.parse(JSON.stringify(pageData));
    }

    pagination = p;
}

function goToPage(pageNum: number) {
    options.currentPage = pageNum;

    if (options.isDataRemote) {
        renderTable();
    } else {
        applyPagination();
    }
}

function updatePageSize() {
    options.currentPage = 1;
    renderTable();
}

function handleSubmittedEdits(event: CustomEvent){
    let rowIndex: number = event.detail.rowIndex;
    let row = data[pageData[rowIndex][dataIdKey]];
    let rowInputs = (<HTMLInputElement>event.detail.domEvent.target).closest('tr')!.querySelectorAll(`[data-name=edit-input]`);

    for (const cellInput of rowInputs) {
        let key = (<HTMLInputElement>cellInput)?.dataset?.key;
        let value = (<HTMLInputElement>cellInput)?.value;
        if (!key) {
            alert('Misconfigured edit-component. See console for details.')
            console.error('Misconfigured edit-component. Add "data-key={instructKey}" to:', cellInput);
            return;
        }
        else if (value == null) {
            alert('Misconfigured edit-component. See console for details.')
            console.error(`Misconfigured edit-component. No value found for the "${key}" cell. Make sure the value is bound to:`, cellInput)
            return;
        }
        row[key] = value;
    }

    row[checkboxKey] = false;
    initialize(instructs, options, data);

    const userCallback = options?.userFunctions?.editSubmissionCallback;
    if (userCallback) {
        userCallback(row);
    }
}

function rowClicked(e: Event, index: number) {
    dispatch('rowClicked', {event: e, data: pageData[index]});
}

function rowDblClicked(e: Event, index: number) {
    dispatch('rowDblClicked', {event: e, data: pageData[index]});
}

function sanitizeHtml(html: string): string {
    let sanitizedHtml = html.replace(/<(?!\/?(div|span|code|strong|b|p|ul|ol|li|u|i|em|sup|sub)( +class="[0-9a-zA-z-_\. ]*")?>)[^>]*>/gi, "");
    return sanitizedHtml
}

export function closePopUps({ target }: Event) {
    const poppedEls = Array.from(document.querySelectorAll('[data-popped=true]') as NodeListOf<HTMLElement>);
    const closestPoppedEl = <HTMLElement>(<HTMLElement>target)?.closest('[data-popped=true]');

    poppedEls.forEach(p => {
        if (p != closestPoppedEl) {
            p.style.visibility = 'hidden';
            p.dataset.popped = '';
        }
    });
}

export function closeMenu(e: Event) {
    if (e) {
        let menuEl = (<HTMLInputElement>e?.target)?.closest<HTMLElement>('div[data-name=menu]');
        if (menuEl) {
            menuEl.style.visibility = 'hidden';
            menuEl.dataset.popped = '';
        }
    }
}

export function toggleMenu(e: Event) {
    let menuEl = (<HTMLInputElement>e?.target)?.parentElement?.querySelector<HTMLElement>('div[data-name=menu]');

    if (menuEl){
        if (menuEl.style.visibility !== 'visible') {
            closePopUps(e);
            menuEl.style.visibility = 'visible';
            menuEl.dataset.popped = 'true';
            e.stopPropagation();
        }
    }
}

export function toggleCheckboxColumn(e: Event) {
    closeMenu(e);

    options.checkboxColumn = !options.checkboxColumn;

    initialize(instructs, options, data);
}

export function selectAllAction(e: Event) {
    closeMenu(e);

    data = data.map(row => {
        row[checkboxKey] = true;
        return row;
    });

    initialize(instructs, options, data);
}

export function selectNoneAction(e: Event) {
    closeMenu(e);

    data = data.map(row => {
        delete row[checkboxKey];
        return row;
    });

    initialize(instructs, options, data);
}

export function invertSelectionAction(e: Event) {
    closeMenu(e);

    data = data.map(row => {
        row[checkboxKey] = !row[checkboxKey];
        return row;
    });

    initialize(instructs, options, data);;
}

export function addAction(e: Event) {
    closeMenu(e);

    let emptyRow: Data = {}

    Object.keys(data[0]).forEach(key => {
        if (key === dataIdKey) {
            emptyRow[key] = data.length;
        } else if (key === checkboxKey) {
            emptyRow[key] = true;
        } else {
            emptyRow[key] = '';
        }
    });

    data = [...data, emptyRow];
    options.currentPage = Math.ceil(data.length / options?.rowsPerPage!);

    initialize(instructs, options, data);
}

export function deleteAction(e: Event) {
    closeMenu(e);
    
    let deletedRows: Data[] = [];
    data = data.filter(row => {
        if (row[checkboxKey]) {
            deletedRows.push(row);
        }
        return !row[checkboxKey];
    });

    initialize(instructs, options, data);

    const userCallback = options?.userFunctions?.deleteActionCallback;
    if (userCallback) {
        userCallback(deletedRows);
    }
}

export function getData(removeMetadata = true, include = ['options','instructs','data','search','filters']) {
    let exportedInstructs: Instructs[] = JSON.parse(JSON.stringify(instructs));

    if (removeMetadata) {
        exportedInstructs = exportedInstructs.filter(instruct => !specialInstructs.hasOwnProperty(instruct.key));
    }

    return {
        options: include.includes('options') ? options : <Options>{},
        instructs: include.includes('instructs') ? exportedInstructs : <Instructs[]>[],
        data: include.includes('data') ? exportData(removeMetadata, data) : <Data[]>[],
        matchedData: include.includes('matchedData') ? exportData(removeMetadata, matchedData) : <Data[]>[],
        sortedData: include.includes('sortedData') ? exportData(removeMetadata, sortedData) : <Data[]>[],
        pageData: include.includes('pageData') ? exportData(removeMetadata, pageData): <Data[]>[],
        formattedPageData: include.includes('formattedPageData') ? exportData(removeMetadata, formattedPageData) : <Data[]>[],
        search: include.includes('search') ? searchObj : <Lookup>{},
        filters: include.includes('filters') ? filterObj : <Record<string, Lookup>>{}
    }
}

function exportData(removeMetadata: boolean, _data: Data[]) {
    if (!removeMetadata) {
        return _data;
    }

    let exportedData: Data[] = JSON.parse(JSON.stringify(_data));

    exportedData.map(row => {
        Object.keys(row).forEach(key => {
            specialInstructs.hasOwnProperty(key) ? delete(row[key]) : null;
        });
        return row;
    });

    return exportedData;
}

// Highlighting
// Assigning numbers to types of matches (search matches, filter matches, overlapping search and filter matches)
const HIGHLIGHT_SEARCH_SEGMENT_TYPE: number = 1;
const HIGHLIGHT_FILTER_SEGMENT_TYPE: number = 2;
const HIGHLIGHT_OVERLAP_SEGMENT_TYPE: number = 3;

// HTML tags to be used for highlighting the matched phrases
let highlightTags = {
    [HIGHLIGHT_SEARCH_SEGMENT_TYPE]: {
        open: `<span class="search-match">`,
        close: `</span>`,
    },
    [HIGHLIGHT_FILTER_SEGMENT_TYPE]: {
        open: `<span class="filter-match">`,
        close: `</span>`,
    },
    [HIGHLIGHT_OVERLAP_SEGMENT_TYPE]: {
        open: `<span class="overlap-match">`,
        close: `</span>`,
    }
}

type HighlightSegment = {
    startChar: number,
    endChar: number,
    type: number
}

type HighlightMatches = {
    [_: string]: number[]
}[];

export function highlighter(pageContent: Data[], ptRef: SvelteComponent, ptInstructs: Instructs[]): Data[] {
    if (ptRef?.getData){
        let searchMatches = locateHighlighterMatches(pageContent, ptRef, ptInstructs);
        pageContent = highlightMatches(pageContent, searchMatches, ptInstructs);
    }
    return pageContent;
}

// This function creates an array of all matched character for each entry
function locateHighlighterMatches(pageContent: Data[], ptRef: SvelteComponent, Instructs: Instructs[]): HighlightMatches {
    let searchPhrase: string;
    let searchIsRegex: boolean;
    let filters: Record<string, {
        value: string,
        isRegex: boolean
    }> = {};
    let matches: HighlightMatches = [];
    
    // Since the component is mounted, the current search and filter phrases will be retrieved using the getData function
    let currentData = ptRef.getData();
    searchPhrase = currentData.search?.value ?? '';
    searchIsRegex = currentData.search?.isRegex ?? false;
    Instructs.forEach(instruct => {
        filters[instruct.key] = {
            value: currentData.filters[instruct.key]?.value ?? '',
            isRegex: currentData.filters[instruct.key]?.isRegex ?? false
        };
    });

    let flags: string | undefined;
    let regexParts: RegexParts | false;

    // Locating the search phrase matches
    if (searchPhrase) {
        let searchRegex = new RegExp('');

        if (searchIsRegex === false) {
            // Creating a Regex safe version of the search phrase
            let pattern = searchPhrase.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&').trim();
            // The non-RegEx search method looks for each word, not the exact phrase
            let words = pattern.toLowerCase().match(/\S+/g);
            if (words?.length) {
                pattern =  words.join('|') ;
            }

            searchRegex = new RegExp(pattern, 'gi');
        }
        else {
            regexParts = getRegexParts(searchPhrase);
            if (!regexParts) { throw new Error('RegEx is not valid!'); }
            flags = regexParts?.flags ?? '';
            searchRegex = new RegExp(regexParts.pattern, flags);
        }

        pageContent.forEach((row, rowIndex) => {
            Instructs.forEach((instruct, instructIndex) => {
                let curMatches: any[] = [];
                // Replace html tags with a non-printable character to exclude them from the search while accounting for their length
                let tagSuppressedRecord = row[instruct.key].replace(/<\/?[^>]*>/g, (m: string)=>Array(m.length + 1).join('\x1F'));

                // Global flag is required for matchAll
                if (searchIsRegex === false || flags?.indexOf('g') !== -1) {
                    curMatches = [...tagSuppressedRecord.matchAll(searchRegex)];
                } else {
                    curMatches = [tagSuppressedRecord.match(searchRegex)];
                }
                
                if (curMatches?.length) {                       
                    if (!matches[rowIndex]) {
                        matches[rowIndex] = {};
                    }
                    if (!matches[rowIndex][instruct.key]) {
                        matches[rowIndex][instruct.key] = [];
                    }

                    curMatches.forEach(match => {
                        if (match){
                            for (let i = match.index; i < match.index + match[0].length; i++) {
                                matches[rowIndex][instruct.key][i] = HIGHLIGHT_SEARCH_SEGMENT_TYPE;
                            }
                        }
                    });
                } 
            });
        });
    }

    // Locating the filter phrase matches
    let filterRegex = new RegExp('');

    Instructs.forEach((instruct, instructIndex) => {
        if (filters[instruct.key]?.value) {
            if (filters[instruct.key].isRegex === false) {
                // Creating a Regex safe version of the search phrase
                let pattern = filters[instruct.key].value.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&').trim();
                // The non-RegEx filter method looks for each word, not the exact phrase
                let words = pattern.toLowerCase().match(/\S+/g);
                if (words?.length) {
                    pattern =  words.join('|') ;
                }
                filterRegex = new RegExp(pattern, 'gi');
            } else {
                regexParts = getRegexParts(filters[instruct.key].value);
                if (!regexParts) { throw new Error('RegEx is not valid!'); }
                flags = regexParts?.flags ?? '';
                filterRegex = new RegExp(regexParts.pattern, flags);
            }

            pageContent.forEach((row, rowIndex) => {
                let curMatches: any[] = [];
                // Replace html tags with a non-printable character to exclude them from the search while accounting for their length
                let tagSuppressedRecord = row[instruct.key].replace(/<\/?[^>]*>/g, (m: string)=>Array(m.length + 1).join('\x1F'));
                
                // Global flag is required for matchAll
                if (filters[instruct.key].isRegex === false || flags?.indexOf('g') !== -1) {
                    curMatches = [...tagSuppressedRecord.matchAll(filterRegex)];
                } else {
                    curMatches = [tagSuppressedRecord.match(filterRegex)];
                }
                
                if (curMatches.length) {                       
                    if (!matches[rowIndex]) {
                        matches[rowIndex] = {};
                    }
                    if (!matches[rowIndex][instruct.key]) {
                        matches[rowIndex][instruct.key] = [];
                    }

                    curMatches.forEach(match => {
                        if (match){
                            for (let i = match.index; i < match.index + match[0].length; i++) {
                                if (matches[rowIndex][instruct.key][i] ?? null) {
                                    matches[rowIndex][instruct.key][i] = HIGHLIGHT_OVERLAP_SEGMENT_TYPE;
                                } else {
                                    matches[rowIndex][instruct.key][i] = HIGHLIGHT_FILTER_SEGMENT_TYPE;
                                }
                            }
                        }
                    });
                } 
            });
        }
    });

    return matches;
}

// This function wraps the matches inside appropriate HTML tags
function highlightMatches(pageContent: Data[], matches: HighlightMatches, Instructs: Instructs[]) {
    let typesArray: number[] = [];
    
    pageContent.forEach((rowData, rowIndex) => {
        Instructs.forEach(instruct => {
            if (typesArray = matches[rowIndex]?.[instruct.key]) {
                let tagType = -1;
                let segment: HighlightSegment = {
                    startChar: -1,
                    endChar: -1,
                    type: -1
                };
                let segments: HighlightSegment[] = [];
                let lastIndex: number = 0;

                typesArray.forEach((type, index) => {                    
                    // If this is the first segment
                    if (tagType === -1) {
                        segment = {
                            startChar: index,
                            endChar: index,
                            type: type,
                        }
                    }
                    // If there is a non-matching gap
                    else if (index - lastIndex> 1) {
                        segments.push({
                            ...segment,
                            endChar: lastIndex
                        });

                        segment = {
                            startChar: index,
                            endChar: index,
                            type: type,
                        }
                    }
                    // If this is a different segment type
                    else if (type != tagType) {
                        segments.push({
                            ...segment,
                        });

                        segment = {
                            startChar: index,
                            endChar: index,
                            type: type,
                        }
                    }
                    // If this is the same segment type
                    else {
                        segment.endChar = index;
                    }

                    tagType = type;
                    lastIndex = index;
                });

                // If there is any unclosed segments
                if (segment.type > 0) {
                    segments.push(segment);
                }

                segments = segments.sort((a,b) => b.startChar - a.startChar);
                
                segments.forEach(segment => {
                    rowData[instruct.key] = [
                        rowData[instruct.key].slice(0, segment.startChar),
                        highlightTags[segment.type].open,
                        rowData[instruct.key].slice(segment.startChar, segment.endChar + 1),
                        highlightTags[segment.type].close,
                        rowData[instruct.key].slice(segment.endChar + 1),
                    ].join('');
                });
            }
        });
    });

    return pageContent;
}

onMount(() => {
    window.addEventListener('click', closePopUps);

    return () => {
        window.removeEventListener('click', closePopUps);
    }
});
</script>


<div data-component="powertable" data-name="main-container" data-prefix="{options.uniquePrefix}" data-status={renderStatus}>
    {#each Object.entries(options.segments ?? {}) as [segment_name, segment_arr]}
        <div data-name={segment_name} data-type="segment">
            {#each segment_arr as segment_code, segment_index}
                {#if segment_code.toLowerCase() === 'search'}
                    <div data-name="search-container" data-segment_index={segment_index}>
                        <label>
                            <span><span>{options.translations?.search}</span></span>
                            <input data-name="search-input" type="text" placeholder=" " data-is_regex={searchObj.isRegex} data-is_custom={searchObj.isCustom} bind:value={searchObj.value} on:input={renderTable}>
                        </label>
                    </div>
                {:else if segment_code.toLowerCase() === 'stats'}
                    <div data-name="stats-container" data-segment_index={segment_index}>
                        {Intl.NumberFormat(options?.translations?.numberFormat)?.format(pagination.firstShownRow ?? 1)}-{Intl.NumberFormat(options?.translations?.numberFormat)?.format(pagination.lastShownRow ?? 1) ?? pagination.lastShownRow} {options.translations?.of} {Intl.NumberFormat(options?.translations?.numberFormat)?.format(options.filteredRows ?? sortedData.length) ?? sortedData.length} 
                        {#if ((options.filteredRows ?? sortedData.length) !== pagination.totalRows) }
                            ({options.translations?.from} {Intl.NumberFormat(options?.translations?.numberFormat)?.format(pagination.totalRows ?? 1) ?? pagination.totalRows})
                        {/if}
                    </div>
                {:else if segment_code.toLowerCase() === 'table'}
                    <div data-name="table-container" data-segment_index={segment_index}>
                        <table>
                            <thead>
                                {#if options.headerLoadingBar}
                                    <tr data-name="loading_bar-tr">
                                        <th colspan={instructs.length}></th>
                                    </tr>
                                {/if}
                                {#if options.headerText}
                                    <tr data-name="titles-tr">
                                        {#each instructs as instruct}
                                            {#if specialInstructs.hasOwnProperty(instruct?.key)}
                                                {#if instruct?.key === checkboxKey && options.checkboxColumn}
                                                    <th data-key={instruct.key} data-sortable={instruct?.sortable}>
                                                        <div data-name="actions-container">
                                                            <button data-name="handle" on:click={toggleMenu}></button>
                                                            <div data-name="menu">
                                                                <button data-name="item" on:click={selectAllAction}>{options.translations?.selectAll}</button>
                                                                <button data-name="item" on:click={selectNoneAction}>{options.translations?.selectNone}</button>
                                                                <button data-name="item" on:click={invertSelectionAction}>{options.translations?.invertSelection}</button>
                                                                <button data-name="item" on:click={addAction}>{options.translations?.add}</button>
                                                                <button data-name="item" on:click={deleteAction}>{options.translations?.delete}</button>
                                                            </div>
                                                        </div>
                                                    </th>
                                                {/if}
                                            {:else}
                                                <th data-key={instruct.key} data-sortable={instruct?.sortable} data-dir={sorting?.[instruct?.key]}>
                                                    <button
                                                        disabled={ ! (instruct?.sortable ?? true)}
                                                        on:click={() => {if(instruct?.sortable !== false){trackSorting(instruct.key)}}}
                                                    ><span>{instruct.title}</span></button>
                                                </th>
                                            {/if}
                                        {/each}
                                    </tr>
                                {/if}
                                {#if options.headerFilters}
                                    <tr data-name="filters-tr">
                                        {#each instructs as instruct}
                                            {#if specialInstructs.hasOwnProperty(instruct?.key)}
                                                {#if instruct?.key === checkboxKey && options.checkboxColumn}
                                                    <th data-key={instruct.key}></th>
                                                {/if}
                                            {:else}
                                                <th data-key={instruct.key}>
                                                    {#if instruct?.filterable !== false}
                                                        <input data-key={instruct.key} data-is_regex={filterObj[instruct.key].isRegex} data-is_custom={filterObj[instruct.key].isCustom} placeholder="{options.translations?.filterBy} {instruct.title}" bind:value={filterObj[instruct.key].value} on:input={renderTable} >
                                                    {/if}
                                                </th>
                                            {/if}
                                        {/each}
                                    </tr>
                                {/if}
                            </thead>
                            <tbody>
                                {#if formattedPageData.length}
                                    {#each formattedPageData as record, index}
                                        <tr data-index={index} data-id={record[dataIdKey]} on:click={(e)=>rowClicked(e, index)} on:dblclick={(e)=>rowDblClicked(e, index)}>
                                            {#each instructs as instruct}
                                                {#if specialInstructs.hasOwnProperty(instruct?.key)}
                                                    {#if instruct.key === checkboxKey && options.checkboxColumn}
                                                        <td data-key={instruct.key}>
                                                            <input type="checkbox" bind:checked={data[record[dataIdKey]][checkboxKey]} />
                                                        </td>
                                                    {/if}
                                                {:else}
                                                    <td data-key={instruct.key}>
                                                        {#if data[record[dataIdKey]]?.[checkboxKey]}
                                                            <svelte:component
                                                                this={instruct.edit?.component}
                                                                rowIndex={index}
                                                                rowId={record[dataIdKey]}
                                                                instructKey={instruct.key}
                                                                instructTitle={instruct.title}
                                                                value={data[record[dataIdKey]][instruct.key]}
                                                                {...instruct.edit?.props}
                                                                on:edit-submit-event={handleSubmittedEdits}
                                                            />
                                                        {:else if instruct?.parseAs === 'component' && instruct?.dataComponent}
                                                            <svelte:component
                                                                this={instruct?.dataComponent}
                                                                rowIndex={index}
                                                                rowId={record[dataIdKey]}
                                                                instructKey={instruct.key}
                                                                value={record[instruct.key]}
                                                            />
                                                        {:else if instruct?.parseAs === 'unsafe-html'}
                                                            {@html (record[instruct.key] ?? '')}
                                                        {:else if instruct?.parseAs === 'html'}
                                                            {@html sanitizeHtml(record[instruct.key] ?? '')}
                                                        {:else}
                                                            {(record[instruct.key] ?? '')}
                                                        {/if}
                                                    </td>
                                                {/if}
                                            {/each}
                                        </tr>
                                    {/each}
                                {:else if renderStatus === 'completed'}
                                    <tr>
                                        <td data-name="noResults-td" colspan={instructs.length}>
                                            {#if $$slots.noResults}
                                                <slot name="noResults" />
                                            {:else}
                                                <div>Nothing to display</div>
                                            {/if}
                                        </td>
                                    </tr>
                                {:else if renderStatus === 'rendering'}
                                    <tr>
                                        <td data-name="rendering-td" colspan={instructs.length}>
                                            {#if $$slots.rendering}
                                                <slot name="rendering" />
                                            {:else}
                                                <div>Loading...</div>
                                            {/if}
                                        </td>
                                    </tr>
                                {/if}
                            </tbody>
                            <tfoot>
                                {#if options.footerFilters}
                                    <tr data-name="filters-tr">
                                        {#each instructs as instruct}
                                            {#if specialInstructs.hasOwnProperty(instruct?.key)}
                                                {#if instruct?.key === checkboxKey && options.checkboxColumn}
                                                    <th data-key={instruct.key}></th>
                                                {/if}
                                            {:else}
                                                <th data-key={instruct.key}>
                                                    {#if instruct?.filterable !== false}
                                                        <input data-key={instruct.key} data-is_regex={filterObj[instruct.key].isRegex} data-is_custom={filterObj[instruct.key].isCustom} placeholder="{options.translations?.filterBy} {instruct.title}" bind:value={filterObj[instruct.key].value} on:input={renderTable} >
                                                    {/if}
                                                </th>
                                            {/if}
                                        {/each}
                                    </tr>
                                {/if}
                                {#if options.footerText}
                                    <tr data-name="titles-tr">
                                        {#each instructs as instruct}
                                            {#if specialInstructs.hasOwnProperty(instruct?.key)}
                                                {#if instruct?.key === checkboxKey && options.checkboxColumn}
                                                    <th data-key={instruct.key} data-sortable={instruct?.sortable}></th>
                                                {/if}
                                            {:else}
                                                <th data-key={instruct.key} data-sortable={instruct?.sortable} data-dir={sorting?.[instruct?.key]}>
                                                    <button
                                                        disabled={ ! (instruct?.sortable ?? true)}
                                                        on:click={() => {if(instruct?.sortable !== false){trackSorting(instruct.key)}}}
                                                    ><span>{instruct.title}</span></button>
                                                </th>
                                            {/if}
                                        {/each}
                                    </tr>
                                {/if}
                                {#if options.footerLoadingBar}
                                    <tr data-name="loading_bar-tr">
                                        <th colspan={instructs.length}></th>
                                    </tr>
                                {/if}
                            </tfoot>
                        </table>
                    </div>
                {:else if segment_code.toLowerCase() === 'dropdown'}
                    <div data-name="dropdown-container" data-segment_index={segment_index}>
                        {options.translations?.rows}
                        <select bind:value={options.rowsPerPage} on:change={updatePageSize}>
                            {#each options.rowsPerPageOptions ?? [] as num}
                                <option value={num}>{Intl.NumberFormat(options?.translations?.numberFormat)?.format(num) ?? num}</option>
                            {/each}
                        </select>
                    </div>
                {:else if segment_code.toLowerCase() === 'settings'}
                    <div data-name="settings-container" data-segment_index={segment_index}>
                        <button data-name="handle" on:click={toggleMenu}></button>
                        <div data-name="menu">
                            {#if $$slots.settings}
                                <slot name="settings" />
                            {:else}
                                <button data-name="item" on:click={toggleCheckboxColumn}>{options.checkboxColumn ? options.translations?.checkboxHide : options.translations?.checkboxShow}</button>
                            {/if}
                        </div>
                    </div>
                {:else if segment_code.toLowerCase() === 'pagination'}
                    <div data-name="pagination-container" data-segment_index={segment_index}>
                        <button
                            disabled={options.currentPage === 1}
                            on:click={()=>options.currentPage !== 1 ? goToPage((options.currentPage ?? 1) - 1) : null}
                        >{options.translations?.previous}</button>

                        {#if pagination.totalPages}
                            {#each pagination.pages ?? [] as pageNum}
                                {#if pageNum === 0}
                                    <button disabled={true}>...</button>
                                {:else}
                                    <button
                                        data-active={options.currentPage === pageNum}
                                        on:click={()=>options.currentPage !== pageNum ? goToPage(pageNum) : null}
                                    >{Intl.NumberFormat(options?.translations?.numberFormat)?.format(pageNum) ?? pageNum}</button>
                                {/if}
                            {/each}
                        {:else}
                            <button data-active={true}>1</button>
                        {/if}

                        <button
                            disabled={!pagination.totalPages || options.currentPage === pagination.totalPages}
                            on:click={()=>options.currentPage !== pagination.totalPages ? goToPage((options.currentPage ?? 1) + 1) : null}
                        >{options.translations?.next}</button>
                    </div>
                {/if}
            {/each}
        </div>
    {/each}
</div>
